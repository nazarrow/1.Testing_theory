# Тест-дизайн и техники тест-дизайна (Test Design and Software Testing Techniques)

*crashtest.by, ISTQB 4.1* - 
**Проектирование теста (Test Design)** - активность по получению и определению тест-кейсов в соответствии с условиями тестирования.

Цель метода проектирования тестов, заключается в определении тестовых условий, тестовых сценариев и тестовых данных.

**Техника тестирования (Test Technique)** - процедура выполняемая для определению тестовых условий, проектированию тестов и тестовых данных.

Дополнительно:
- [Тест-дизайн и техники тест-дизайна (Test Design and Software Testing Techniques)](https://vladislaveremeev.gitbook.io/qa_bible/test-dizain/test-dizain-i-tekhniki-test-dizaina-test-design-and-software-testing-techniques)

ОБРАТИТЬ ВНИМАНИЕ ! СТАТИЧЕСКИЕ И ДИНАМИЧЕСКИЕ

## Техники тестирования методом чёрного ящика (Black-box test techniques)

**Техники тестирования методом чёрного ящика (Black-box test techniques)** - техники тестирования, основанные на анализе спецификации компонента или системы.

Методы черного ящика (поведенческие, или методы, основанные на поведении) основываются на анализе соответствующего базиса тестирования (формальных требований, спецификаций, сценариев использования, пользовательских историй или бизнес-процессов). Эти методы применимы как для функционального, так и для нефункционального тестирования. Методы черного ящика сосредотачиваются на связи входных данных и выходных результатов объекта тестирования, а не на его внутренней структуре.

Техники метода черного ящика:
- **Эквивалентное разбитие (Equivalence partitioning);**
- **Анализ граничных значений (Boundary value analysis);**
- **Анализ доменов (Domain analysis);**
- **Тестирование всех пар (All pairs testing, Pairwise);**
- **Тестирование таблицы решений (Decision table testing);**
- **Тестирование диаграммы переходов состояний (State transition testing);**
- **Графики причинно-следственных связей (Cause-Effect Graphing);**
- **Тестирование сценариев использования (Use Case Testing);**
- **Тестирование историй использования (User Story Testing).**

Дополнительно:
- [Dynamic - Black box](https://vladislaveremeev.gitbook.io/qa_bible/test-dizain/dynamic-black-box)

### Эквивалентное разбитие (Equivalence partitioning)

*ISTQB 4.2.1* - 
Эквивалентное разбиение делит данные на группы (классы эквивалентности), которые, как предполагается, обрабатываются схожим образом [Kaner 2013], [Jorgensen 2014]. Области эквивалентности могут быть как для правильных, или позитивных, так и неправильных, или негативных, значений.

- Позитивные значения – это значения, которые должны быть приняты. Класс, содержащий позитивные значения, называется «действительный класс эквивалентности».
- Негативные значения – значения, которые должны быть отвергнуты. Класс, содержащий негативные значения, называется «недействительный класс эквивалентности».
- Классы могут быть определены для любых данных, относящихся к объекту тестирования, включая: входные данные, выходные данные, внутренние данные, данные, связанные со временем (например, до или после события), интерфейсные параметры (например, в случае интеграционного тестирования компонентов).
- Любой класс может быть при необходимости разделен на подклассы.
- Каждое значение должно принадлежать только одному классу эквивалентности.
- Во избежание маскирования дефектов негативные классы эквивалентности в тестовых сценариях следует использовать по отдельности, то есть избегать комбинаций одних негативных классов с другими. Дефекты могут быть маскированы, если при наличии нескольких дефектов обнаруживается только один из них.

Для достижения 100% покрытия с помощью этого метода, тестовые сценарии должны покрывать все позитивные и негативные классы, проверяя хотя бы одно значение из каждого класса. Покрытие вычисляется как отношение количества тестируемых классов к общему числу классов. Метод эквивалентного разбиения применим на всех уровнях тестирования.

*crashtest.by* -
**Эквивалентная область или класс эквивалентности (Equivalence partition)** - часть области значений элемента данных, связанного с тестовым объектом, для которого все значения должны обрабатываться одинаково на основе спецификации.

**Эквивалентное разбиение (Equivalence partitioning)** - техника тестирования методом черного ящика, где тестовые сценарии создаются для тестирования эквивалентных разбиений путем использования одного представителя каждого разбиения

Суть техники эквивалентного разбиения в том, чтобы:
- Разделить данные на группы (классы эквивалентности), которые, как
предполагается, обрабатываются системой схожим образом (то есть ведут
систему к одному состоянию);
- Из каждой группы (класса) выбрать одно значение и проверить его.

Два теста эквивалентны, если выполняются все условия:
- Оба теста направлены на поиск одной и той же ошибки;
- Если один из тестов обнаруживает ошибку, другой скорее всего, тоже её обнаружит;
- Если один из тестов не обнаруживает ошибку, другой, скорее всего, тоже её не обнаружит;
- Тесты используют схожие наборы входных данных;
- Для выполнения тестов мы совершаем одни и те же операции;
- Тесты генерируют одинаковые выходные данные или приводят приложение в одно и то же состояние;
- Все тесты приводят к срабатыванию одного и того же блока обработки ошибок;
- Ни один из тестов не приводит к срабатыванию блока обработки ошибок.

Пример:
Текстовое поле от 3 до 20 символов по длине.

По этому требованию мы можем выделить следующие классы:
- 0-2 символов – выдаст ошибку, что поле имеет недостаточное количество символов;
- 3-20 символов – обработается верно;
- 21-бесконечность – выдаст ошибку, что поле превышает разрешенное количество символов.

[*habr.com*](https://habr.com/ru/post/462553/) - 
**Класс эквивалентности (Equivalence class)** – это набор входных (или выходных) данных ПО, которые обрабатываются программой по одному алгоритму или приводят к одному результаты.

То есть, это некое множество значений, которое вы можете подставлять в программу и получать один и тот же результат. Результатом можем быть не только конкретные значения, действия программы, но и просто область применения. Поэтому, самые простые классы эквивалентности, на которые делятся проверки, это 2 основных класса: позитивные и негативные сценарии.

Далее, каждый класс эквивалентности можем разделить на дополнительные классы и т.д. до того момента, пока проверки не будут приводить к точечным и конкретным результатам тестирования.  
  
Рассмотрим пример:  
  
Система скорринга рассчитывает процентную ставку по кредиту для клиента исходя из его возраста, который вводится в форму:  
  
- От 18 до 25 лет – 18%
- От 25 до 45 лет – 16 %
- Свыше 45 лет – 20%

Мы определяем 2 основных класса – это **позитивные и негативные** сценарии.  
  
Позитивными сценариями будут все значения, которые приводят к получению результата, негативными сценариями – значения, результаты которых не описаны, как ожидаемый результат.  
  
Далее мы делим класс позитивных сценариев 3 класса вводимых значений 18-24, 25-44 и 45 +  
  
В классе негативных сценариев мы формируем значения, исходя из необходимости проверки отказов программы, поэтому мы имеем 0, 1-17, отрицательные значения, ввод символов и т.д.  
  
Результатом данного разбиения будет значение или диапазон значений, в котором нам необходимо выполнить всего одну проверку с любым значением из диапазона данных. Могут возникнуть такие ситуации, как одно значение в диапазоне. Это тоже отдельный класс эквивалентности и тоже требует проверки.  
  
Итого мы имеем.  

- Позитивные проверки: Ввод значений: 19, 30, 48 (значения могут быть любыми из данного диапазона класса)
- Негативные проверки: 0, 3, -1, А и т.д.

### Анализ граничных значений (Boundary value analysis)

*ISTQB 4.2.2* - 
Метод анализа граничных значений является продолжением метода эквивалентного разбиения, но может быть применим, только если классы состоят из упорядоченных числовых значений. Максимальное и минимальное значение класса являются его границами [Beizer 1990].

Для примера, предположим, что некоторое поле ввода принимает положительное целое число от 0 до 9; ввод осуществляется через клавиатуру, поэтому нечисловые входные значения исключены. Допустимы значения от 1 до 5 включительно. Таким образом, можно выделить три области эквивалентности: негативная (слишком маленькие), позитивная, негативная (слишком большие). Для позитивной области эквивалентности значения 1 и 5 будут граничными. Для области с негативными большими значениями границами будут значения 6 и 9. Для области с негативными малыми значениями будет только одна граница – 0, поскольку эта область состоит из одного элемента.

В рассмотренном выше примере мы можем определить по два граничных значения на каждую из границ. Граница между негативными малыми и позитивными значениями дает нам тестовые значения 0 и 1. Граница между позитивными и негативными большими значениями дает нам тестовые значения 5 и 6. Вариация данного метода определяет три граничных значения на каждую из границ: значения перед, на и сразу после границы. Для рассматриваемого примера применение этого метода даст следующие тестовые значения: для нижней границы – 0,1,2; для верхней границы – 4,5,6 [Jorgensen 2014].

Некорректное поведение более вероятно на границах класса, чем внутри класса. Важно помнить, что специфицированные и реализованные границы могут быть смещены вверх или вниз относительно истинных значений, они могут быть пропущены или дополнены новыми границами. Анализ и тестирование граничных значений может обнаружить большинство подобных дефектов, вынуждая программное обеспечение демонстрировать поведение, относящееся к области эквивалентности, отличной от той, к которой должна относиться граничная точка.

Анализ граничных значений может использоваться на любом уровне тестирования. Данный метод применяется при тестировании требований, в которых присутствуют диапазоны значений (включая даты и время). Покрытие вычисляется как отношение числа тестируемых граничных значений к общему числу граничных значений и чаще всего выражается в процентах.

*crashtest.by* -
**Анализ граничных значений (Boundary value analysis)** - разработка тестов методом черного ящика, при котором тестовые сценарии проектируются на основании граничных значений.

**Граничное значение (Boundary value)** - минимальное или максимальное значение, принадлежащее упорядоченной эквивалентной области (классу эквивалентности).

Пример:
Текстовое поле от 3 до 20 символов по длине.

Для проверки длины поля мы уже выделили 3 класса:
от 0 до 2, от 3 до 20, от 21 и выше.

Соответственно можно выделить следующие границы переходов:
| invalid | valid   | invalid |
| ------- | ------- | ------- |
| 2       | 3    20 | 21      |

В рамках техники анализа граничных значений мы должны сделать тесты для
проверки вышеуказанных значений:
2: Bo
3: Bat
20: BatmanAndRobinReturn
21: BatmanAndRobinForever

Существует 2 подхода к анализу граничных значений:
-  2 значения на границе (Two-value boundaries);
	- Минимальная граница: 2, 3 символов
	- Максимальная граница 20, 21 символов
- 3 значения на границе (Three-value boundaries).
	- Минимальная граница: 2, 3, 4 символов
	- Максимальная граница 19, 20, 21 символов

[*habr.com*](https://habr.com/ru/post/462553/) - 
Неотъемлемой часть проверки любого элемента является другая техника – **граничные значения**.  
  
Граничные значения дополняют эквивалентные классы, тем самым полностью покрывая проверки элемента ПО.  
  
**Граничные значения** – техника тест-дизайна, которая дополняет классы эквивалентности дополнительными проверками на границе изменения условий.  
   
Вернемся к нашему примеру ранее.  
  
Система скорринга рассчитывает процентную ставку по кредиту для клиента исходя из его возраста, который вводиться в форму:  

- От 18 до 25 лет – 18%
- От 25 до 45 лет – 16 %
- Свыше 45 лет – 20%

Что же здесь будет границей?  
  
Чтобы определить граничные значения нужно нечто иное. А именно, определить, какие значения являются начальным и конечным для нашего класса. И самое важное!!! Годы исследований в области тестирования показали, что бОльшая часть дефектов находится тестировщиками именно на стыке значений, которые меняют условия работы программы.  
  
Поэтому, помимо граничного значения мы используем для тестирования дополнительно 2 значения, значение перед границей и значение после границы.  
  
В итоге мы имеем:  
  
Границы наших классов: 17, 18, 19, 24, 25, 26, 44, 45, 46 и max.  
  
Также, у нас есть негативный класс, это от 0 до 18. Поэтому тут мы тоже должны использовать для тестирования граничные значения: -1, 0, 1, 17,18  
  
Далее исключаем повторяющиеся значения, и получаем значения для проверки элемента ввода данных.  
  
-1, 0, 1, 17, 18, 19, 24, 25, 26, 44, 45, 46, max.  
  
Значение max обычно уточняется у Заказчика или аналитика. Если не могут предоставить, то следует бросить его и не проверять необходимо подобрать значение, соответствующее здравому смыслу (вряд ли кто-то придет за кредитов в возрасте 100 лет).  
  
Следующий шаг, это наложить граничные значения на значения классов эквивалентности, исключить лишние проверки, пользуясь правилом «достаточно одного значения для проверки одного класса» и финализировать список.  
  
Если ранее у нас были 3 значения для 3-х классов, 19, 30 и 48, то после определения граничных значений, мы можем исключить из списка значения 30 и 48 и заменить их предграничными значениями, такими как 26 (вместо 30) и 46 (вместо 48).  
  
Граничные значения определяются не только для числовых значений, но и для буквенных (например, границы алфавита и кодировки), даты и времени, смысловых значений. Граница числовых значений зависит от формата ввода, если у вас целые числа, например, 2, то граничные значения будут 1 и 3. Если дробные значения, то границы для числа 2 уже будут 1,9 (1,99) или 2,1 (2,01) и т.д.

Дополнительно:
- [Техники тест-дизайна: теория и примеры](https://testengineer.ru/tekhniki-test-dizajna-teoriya-i-primery/)

### Анализ доменов (Domain analysis)

*crashtest.by* -
**Доменное тестирование/Анализ доменов (Domain analysis)** - техника тестирования метода чёрного ящика, направленная на уменьшение количества тестов путём одновременной проверки множества различных позитивных значений. Данная техника базируется на одновременном использовании техник эквивалентного разбиения и анализа граничных значений.

Продолжение: 
- [ТЕХНИКИ ТЕСТ ДИЗАЙНА: ДОМЕННОЕ ТЕСТИРОВАНИЕ (ЭКВИВАЛЕНТНОЕ РАЗБИЕНИЕ И АНАЛИЗ ГРАНИЧНЫХ ЗНАЧЕНИЙ)](https://crashtest.by/domain-testing/)

### Тестирование всех пар/ попарное (All pairs testing, Pairwise)

*crashtest.by* - 
**Попарное тестирование (Pairwise testing)** - техника тестирования методом черного ящика, при которой тестовые сценарии разрабатываются таким образом, чтобы выполнить тестирование для всех комбинаций параметр-значение.

Подходит для:
- Тестирование взаимодействия большого числа параметров

Не подходит для:
- Негативные сценариев
- Не работает, если количество параметров маленькое, а значений большое

[*habr.com*](https://habr.com/ru/post/462553/) - 
Основной техникой тест-дизайна **parwise testing (попарное тестирование)**. Суть техники заключается в минимизации вариативности комбинаций проверок, достаточных для обеспечения высокого качества ПО.  
  
Простыми словами, в данной технике применяется правило Парето, 80 % качества можно достичь всего 20% проверок комбинаций данных.

Для составления комбинаций:
https://pairwise.teremokgames.com/

Дополнительно:
- [ТЕХНИКА ПОПАРНОГО ТЕСТИРОВАНИЯ](https://sedtest-school.ru/test-design/test-dizajn-tehnika-poparnogo-testirovaniya/)

### Тестирование таблицы решений (Decision table testing)

*crashtest.by* -
Тестирование таблицы решений (Decision table testing) - техника тестирования методом черного ящика, в которой тестовые сценарии проектируются для проверки комбинаций условий и действий, отраженных в таблице решений.

Плюсы подхода:
- Наглядность помогает найти баги в документации
- Таблица помогает не забыть ничего важного

Минусы подхода:
- Не работает если много условий.

Дополнительно:
- [Decision Table — что это и как применять](https://habr.com/ru/post/546432/)
- [Что такое таблица решений?](https://testengineer.ru/chto-takoe-tablica-reshenij/)

### Тестирование диаграммы переходов состояний (State transition testing)

*crashtest.by* -
**Тестирование таблицы переходов (State transition testing)** - разработка тестов методом черного ящика, при котором сценарии тестирования строятся на основе модели переходов состояний.

Плюсы подхода:
- Может применяться везде, где есть переходы из одного состояния в другое
- Позволяет увидеть, то что могло быть пропущенным

Минусы подхода:
- Тяжело поддерживать
- Для тестирования веб-сервисов не всегда очевидны все состояния

Дополнительно:
- [State & Transition Diagram — что это и как применять](https://habr.com/ru/post/548192/)



## Техники тестирования метода белого ящика (White-box test techniques)

*ISTQB 4.3* -
Методы белого ящика (структурные, или методы, основанные на структуре) основаны на анализе архитектуры, детального проектирования, внутренней структуры или кода компонента либо системы. В отличие от методов черного ящика методы белого ящика сосредотачиваются на структуре и обработке внутри объекта тестирования.

Тестирование белого ящика основывается на внутренней структуре объекта тестирования. Методы могут применяться на всех этапах, однако, методы, рассмотренные ниже, чаще всего используются в модульном тестировании.
Существуют и другие методы, используемые в тестировании критичных систем и обеспечивающие более сильное покрытие, но здесь они не рассматриваются. Более подробная информация об этих методах размещена в программе подготовки продвинутого уровня (ISTQB Продвинутый уровень, Технический тест-аналитик).

4.3.1 Тестирование и покрытие операторов
Тестирование операторов направлено на проверку исполняемых операторов в коде. Покрытие вычисляется как отношение количества операторов, выполненных тестом, к общему числу операторов в тестируемом коде.

4.3.2 Тестирование и покрытие условий
Тестирование условий направлено на проверку логических условий в коде, а также кода, выполняемого в зависимости от исхода условия. Для этого тесты следуют потокам управления, которые выходят из условия (путь для выхода «истина» и для выхода «ложь»; для оператора выбора (CASE) тесты потребуются для всех возможных результатов, включая выход по умолчанию).
Покрытие вычисляется как отношение числа исходов условий, проверенных тестом, к общему числу исходов тестируемых условий.

4.3.3 Ценность тестирования операторов и условий
Стопроцентное покрытие операторов означает проверку всех исполняемых инструкций в коде хотя бы один раз, но это не дает уверенности в проверке логики условий. Из двух методов, рассматриваемых здесь, тестирование операторов обеспечивает более слабое покрытие, чем тестирование условий.
Стопроцентное покрытие условий проверяет все ветки потока управления, что включает проверку выходов «истина» и «ложь» для условных операторов. Покрытие условий позволяет находить ситуации, в которых исполняемый код может быть пропущен в зависимости от результата условия.
Стопроцентное покрытие условий гарантирует стопроцентное покрытие операторов, но не наоборот.

## Техники, основанные на опыте (Experience based test techniques)

*ISTQB 4.4* -
Методы, основанные на опыте, используют опыт разработчиков, тестировщиков и пользователей для проектирования, реализации и выполнения тестов. Их часто совмещают с методами черного и белого ящиков.

При использовании методов тестирования, основанных на опыте, тесты создаются на основе умения, интуиции и опыта тестировщика. Данные методы могут пригодиться при создании тестов, которые невозможно получить, применяя другие, более системные методы. В зависимости от выбранного подхода и прошлого опыта можно получить очень разные степени покрытия и эффективности тестирования. Измерение покрытия для данных методов может быть затруднительным или вообще невозможным.
Наиболее популярные методы рассматриваются в последующих разделах.

4.4.1 Предположение об ошибках
Предположение об ошибках – это способ предотвращения ошибок, дефектов и отказов, основанный на знаниях тестировщика, включающих:
- Историю работы приложения в прошлом
- Наиболее вероятные типы дефектов, допускаемых при разработке
- Типы дефектов, которые были обнаружены в схожих приложениях
Структурированный подход к предположению об ошибках предполагает создание списка всех возможных ошибок, дефектов и отказов с последующей разработкой тестов, направленных на поиск дефектов из этого списка. Списки отказов и дефектов могут быть построены на основе опыта, исторических данных об отказах и ошибках, а также на общих знаниях о причинах отказа программ.

4.4.2 Исследовательское тестирование
Во время исследовательского тестирования неформальные (т.е. не созданные заранее) тестовые сценарии разрабатываются, выполняются, анализируются и оцениваются динамически во время выполнения тестов. Результаты тестирования используются для изучения компонента или системы и последующей разработки тестовых сценариев для непокрытых областей.
Исследовательское тестирование может проводиться сессиями, что позволяет структурировать активность. При использовании сессионного подхода, исследовательское тестирование выполняется в определенном промежутке времени, при этом тестировщик использует концепцию тестирования, содержащую цели, и отмечает выполненные действия и обнаруженные факты.
Исследовательское тестирование лучше всего подходит в ситуациях, когда документация недостаточная, либо вовсе отсутствует, в условиях очень сжатых сроков и как дополнение к другим, более формальным, методам тестирования.
Исследовательское тестирование относится к реактивным стратегиям тестирования и может включать использование различных методов черного и белого ящиков или методов, основанных на опыте.

4.4.3 Тестирование на основе чек-листов
При тестировании по чек-листам тестировщик проектирует, реализует и выполняет тесты, покрывающие тестовые условия, указанные в чек-листе. В качестве составной части анализа тестировщики могут создавать новые или расширять чек-листы, либо использовать готовые чек-листы, не меняя их. Такие списки могут быть построены на опыте, на исторических данных об ошибках, на информации о приоритетах для пользователей и понимании, как и почему происходят отказы в программе.
Чек-листы могут создаваться для поддержки разных видов тестирования, включая функциональное и нефункциональное тестирование. При отсутствии детальных тестовых сценариев, чек-листы помогают определить направления тестирования и увеличивают согласованность тестирования. Поскольку чек-листы содержат общее описание, это снижает повторяемость результатов.

Дополнительно:
- [Dynamic - Experience based](https://vladislaveremeev.gitbook.io/qa_bible/test-dizain/dynamic-experience-based)





Дополнительная информация: